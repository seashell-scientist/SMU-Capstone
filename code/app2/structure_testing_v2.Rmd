---
title: "R Notebook"
output: html_notebook
---

aggregate function v0
```{r setup, include=FALSE}
library(rmdformats)
library(tidyverse)  # data manipulaiton
library(data.table)
library(tswge)  # Time series package
library(tseries)  # for Dickey-Fuller test 
library(orcutt)  # for Cochrane-Orcutt test
library(formattable)  # for table formatting
library(GGally)
library(astsa)
library(nnfor)
library(dplyr)
library(ggplot2)
library(changepoint)
library(date)
library(R.devices)
knitr::opts_chunk$set(echo = TRUE,
                      prompt = FALSE,
                      tidy = TRUE,
                      comment = NA,
                      message = FALSE,
                      warning = FALSE)
```

```{r data}
#df = read.csv("D:/SMU/DS 6120 Capstone A/appv2/merged_2013-2019.csv")
df = read.csv("merged_2013-2019.csv")
df$date = date.mmddyy(mdy.date(match(substr(df$Month, 4, 6),month.abb),01,df$Year),sep="/") #not sure why original had different substring matches for different years, check for errors later

check.for.missing.data <- function(data){
  a = colnames(data)
  b = colSums(is.na(df))  %>% as.data.table
  missing_value_table = cbind(a, b)
  colnames(missing_value_table) = c("Variables","Missing_values")
  missing_value_table = missing_value_table  %>% filter(Missing_values>0)  %>% 
    mutate("As a % of Total Values" = round(100 * (Missing_values / nrow(df)), 1))  %>% 
    arrange(desc(Missing_values))
  head(missing_value_table, 20)}
table_a = check.for.missing.data(data=df)
invisible(df %>% filter(Account_Status != "Closed"))
drops <- c("Metrics","Year","Month","House","Account_Status","Beverage_Type","Fiscal_Year","Premise","Customer_Street_Address","Customer_City",
           "Customer_Zip_Code","Longitude_Customer","Latitude_Customer","Customer","Vendor","Brand_ID","Brand","Size","Product_ID","Chain","Category",
           "Product_Type_ID","Qty_Per_Case","Alcohol_Proof","X9L_Cases","Dollar_Sales_Per_Case","Dollar_Sales_Per_9L_Case")
df = df[ , !(names(df) %in% drops)]
df$Dollar_Sales = as.numeric(gsub('[$,]', '', df$Dollar_Sales))
# Create file with all possible combinations
combinations0 = as.data.frame(df %>% group_by(Product_Type, Product, Customer_ID) %>% tally(sort=TRUE))
combinations = combinations0 %>% filter(n >= 42)
```
############################
###BEGIN FUNCTION STORAGE###
############################
```{r}
#Equal Means
#accept df object and return forcasts 1:12
em_ts <- function(n_ahead, target_df){
  return(rep((mean(target_df$STD_Cases)),  n_ahead))}
```

```{r}
#bootleg AIC5 with no tswge
#target_vector <- target_df$STD_Cases 
aic_boot <- function(target_vector){
  pqc <- expand.grid(0:5, 0:2)
  aic_holder <- vector()
  p_holder <- vector()
  q_holder <- vector()
  for(i in 1:length(pqc$Var1)) {
    temp_model <- arima(target_vector, order = c(pqc[i, 1], 0, pqc[i, 2]))
    #aic_holder <- append(aic_holder, temp_model$aic) #base AIC with k = 2?
    aic_holder[i] <- AIC(temp_model, k = log(length(target_vector)))
    p_holder <- append(p_holder, pqc[i, 1])
    q_holder <- append(q_holder, pqc[i, 2])}
  aic_results <- data.frame(p = p_holder, q = q_holder, aic = aic_holder)
  aic_results <- aic_results[order(aic_results$aic), ]
  return(head(aic_results, 1))
}
#AIC values are way off, look at source for calculations later? but the order for similar tests to tswge seems close enough 
```


```{r}
#AR #use commented sections if tswge works
ar_ts <- function(n_ahead, target_df){
  model1 = aic.wge(target_df$STD_Cases ,q=0,type="aic") %>% invisible()
  if (model1$p == 0){
    newphi = 1
  } else {
    newphi = model1$p
  }
  model1_est = est.ar.wge(target_df$STD_Cases ,p=newphi, factor = FALSE) %>% invisible()
  forecasts = fore.aruma.wge(target_df$STD_Cases,phi = model1_est$phi, theta = 0, s = 0, d = 0,n.ahead = n_ahead,plot=FALSE) %>% invisible()
  return(forecasts$f)
}
#looks to work, but prints several polynomial coefficient output
#ar_ts(5, target_df) 
```

```{r}
#AR model bootleg
ar_ts_boot <- function(n_ahead, target_df){
  aic_temp <- aic_boot(target_df$STD_Cases)
  if (aic_temp$p == 0){
    newphi = 1}
  else{newphi = aic_temp$p}
  model_temp <- arima0(target_df$STD_Cases, order = c(newphi, 0, 0), method = 'ML') #note q is zero for AR model
  pred_temp <- invisible(predict(model_temp, n_ahead))
  return(pred_temp$pred)
}
#ar_ts_boot(5, target_df) #close enough
```

```{r}
#ARMA
arma_ts <- function(n_ahead, target_df){
  model1 = aic.wge(target_df$STD_Cases,type="aic") %>% invisible()
  model1_est = est.arma.wge(target_df$STD_Cases,p=model1$p,q=model1$q) %>% invisible()
  forecasts = fore.aruma.wge(target_df$STD_Cases,phi = model1_est$phi, theta = model1_est$theta, s = 0, d = 0,n.ahead = n_ahead,plot=FALSE)
  return(forecasts$f)} #can't hide coefficient output by assigning to var ??
#arma_ts(8, target_df)
```

```{r}
arma_ts_boot <- function(n_ahead, target_df){
  aic_temp <- aic_boot(target_df$STD_Cases)
  if (aic_temp$p == 0){
    newphi = 1}
  else newphi = aic_temp$p #error if inside curly brackets??? 
  model_temp <- arima0(target_df$STD_Cases, order = c(aic_temp$p, 0, newphi)) #note q is not zero for ARMA model
  pred_temp <- predict(model_temp, n_ahead) %>% invisible()
  return(pred_temp$pred)
}
#arma_ts_boot(8, target_df)
```

```{r}
#ARI (q = 0 and d = 1)
ari_ts <- function(n_ahead, target_df)
{
  temp2 = artrans.wge(target_df$STD_Cases, 1) %>% invisible() #take difference
  model1 = aic.wge(temp2,q=0,type="aic") %>% invisible()
  if (model1$p == 0){
    newphi = 1
  }else{newphi = model1$p}  
  model1_est = est.ar.wge(temp2,p=newphi) %>% invisible() #won't work will all zero?
  forecasts = fore.aruma.wge(target_df$STD_Cases,phi = model1_est$phi, theta = 0, s = 0, d = 1,n.ahead = n_ahead,plot=FALSE) %>% invisible()
  return(forecasts$f)
}
#ari_ts(12, target_df)
```

```{r}
#ARI no tswge
ari_ts_boot <- function(n_ahead, target_df){
  diff1 <- diff(target_df$STD_Cases)
  aic_temp <- aic_boot(diff1)
  if (aic_temp$p == 0){
    newphi = 1}
  else{newphi = aic_temp$p}
  pred_temp <- predict(arima0(target_df$STD_Cases, order = c(newphi, 1, 0)), n.ahead = n_ahead)
  return(pred_temp$pred)
}
#ari_ts_boot(12, target_df) #close enough
```

```{r}
#ARIMA (with d = 1?)
arima_ts <- function(n_ahead, target_df){
  diff1 = artrans.wge(target_df$STD_Cases, 1) %>% invisible()
  aic_temp = aic.wge(diff1, type = 'aic') %>% invisible()
  model_temp <- est.arma.wge(diff1, p = aic_temp$p, q = aic_temp$q) %>% invisible()
  pred_temp <- fore.aruma.wge(target_df$STD_Cases, phi = model_temp$phi, theta = model_temp$theta, s = 0, d = 1, n.ahead = n_ahead, plot = FALSE)
  return(pred_temp$f)
}
#arima_ts(4, target_df)
```

```{r}
#no tswge
arima_ts_boot <- function(n_ahead, target_df){
  diff1 = diff(target_df$STD_Cases)
  aic_temp <- aic_boot(diff1)
  if (aic_temp$p == 0){
    newphi = 1}
  else{newphi = aic_temp$p}
  pred_temp <- predict(arima0(target_df$STD_Cases, order = c(newphi, 1, aic_temp$q)), n.ahead = n_ahead)
  return(pred_temp$pred)
}
#arima_ts_boot(4, target_df) #it's off by ~10%? 
```

```{r}
#ARI_S12 #(p, 1, 0), s = 12
ari_s12_ts <- function(n_ahead, target_df){
  seasonal1 <- artrans.wge(target_df$STD_Cases,phi.tr=c(rep(0,11),1))
  aic_temp <- aic.wge(seasonal1, q = 0, type = 'aic')
  if (aic_temp$p == 0){
    newphi = 1
  } else {
    newphi = aic_temp$p
  } 
  model_temp <- est.ar.wge(seasonal1, p = newphi) 
  pred_temp <- fore.aruma.wge(target_df$STD_Cases, phi = model_temp$phi, theta = 0, s = 12, d = 0, n.ahead = n_ahead, plot = FALSE)
  
  return(pred_temp$f)
}
#ari_s12_ts(5, target_df)
```

```{r}
#bootleg ARI_S12
ari_s12_ts_boot <- function(n_ahead, target_df){
  diff1 <- diff(target_df$STD_Cases)
  aic_temp <- aic_boot(diff1)
  if (aic_temp$p == 0){
    newphi = 1
  } else {
    newphi = aic_temp$p
  } 
  #using astsa library sarima? 
  pred_temp <- sarima.for((target_df$STD_Cases), n_ahead, p = newphi, d = 0, q = 0, P = 0, D = 0, Q = 0, S = 12) %>% invisible
  return(pred_temp$pred) }
#ari_s12_ts_boot(5, target_df) #+2% off from the tswge function
```

```{r}
#ARIMA_S12 #(p, 0, q), s = 12
arima_s12_ts <- function(n_ahead, target_df){
  aic_temp <- aic.wge(target_df$STD_Cases, type = 'aic')
  if (aic_temp$p == 0){
    newphi = 1
  } else {
    newphi = aic_temp$p
  } 
  model_temp <- est.arma.wge(target_df$STD_Cases, p = newphi, q = aic_temp$q) 
  pred_temp <- fore.aruma.wge(target_df$STD_Cases, phi = model_temp$phi, theta = model_temp$theta, s = 12, d = 0, n.ahead = n_ahead, plot = FALSE)
  
  return(pred_temp$f)
}
#arima_s12_ts(5, target_df)
```

```{r}
#bootleg ARIMA_S12
arima_s12_ts_boot <- function(n_ahead, target_df){
  diff1 <- diff(target_df$STD_Cases)
  aic_temp <- aic_boot(diff1)
  if (aic_temp$p == 0){
    newphi = 1
  } else {
    newphi = aic_temp$p
  } 
  #using astsa library sarima? 
  pred_temp <- sarima.for((target_df$STD_Cases), n_ahead, p = newphi, d = 0, q = aic_temp$q, P = 0, D = 0, Q = 0, S = 12) %>% invisible
  return(pred_temp$pred) }
#arima_s12_ts_boot(5, target_df) #+2% off from the tswge function
```

```{r}
#RF function
library(ranger)
library(randomForest)
library(caret)
#with no graph
rf_ts <- function(n_ahead, target_df){
  target_df$date <- as.Date(target_df$date, '%m/%d/%Y')
  tlen = length(target_df$STD_Cases)
  sample_train <- target_df[1:(tlen-n_ahead), ]
  sample_test <- target_df[(tlen-n_ahead +1):tlen, ]
  sample_test$Dollar_Sales[is.na(sample_test$Dollar_Sales)] <- 0
  rf1 <- randomForest(STD_Cases ~date + Dollar_Sales, data = sample_train, na.action = na.exclude)
  pred1 = predict(rf1, newdata = sample_test)
  rf_ase <- mean((sample_test$STD_Cases - pred1)^2)
  predictions <- data.frame(date = sample_test$date, forecast = pred1)
  results = c(predictions, data.frame(ASE = rf_ase))
  #return(results)
  return(results$forecast)
}
```

```{r}
#nn complete
nnc <- function(target_df, n_ahead, reps, hd_vector, display){
  #date_line <- as.Date(target_df$date, '%m/%d/%Y') #add date back in after it works
  tlen <- length(target_df$STD_Cases)
  sample_train <- target_df[1:(tlen-n_ahead), ]
  sample_test <- target_df[(tlen-n_ahead +1):tlen, ]
  
  ts_train<- as.ts(sample_train$STD_Cases)
  fit_mlp <- mlp(ts_train, reps = reps, hd = hd_vector)
  
  mlp_pred <- forecast(fit_mlp, h = n_ahead)
  mlp_ase <- mean((sample_test$STD_Cases - mlp_pred$mean)^2)
  
  #r1 <- ggplot() + 
  #  geom_line(aes(x = sort(target_df$date), y = target_df$STD_Cases), col = 'black') +
  #  geom_line(aes(x = sort(target_df$date), y = c(rep(NA, (tlen-n_ahead)), mlp_pred$mean)), col = 'red') +
  #  ggtitle(paste('MLP', n_ahead, 'Month ASE: ', mlp_ase), subtitle =paste(target_df$Product[1], 'Purchases By Cust ID: ', target_df$Customer_ID[1]))
  
  #if(display == TRUE){
  #  print(fit_mlp)
  #  plot(fit_mlp)
  #  show(r1)}
  
  forecasts <- data.frame(forecast = mlp_pred$mean)
  return(c(forecasts, mlp_ase))
}
```

```{r, warning = FALSE}
#function that accepts function for collated rolling ase 1:12 based on trainingSize ect, so i can just swap ar_ts with rf_ts and reuse the same evaluation matrix 
ase_gen <- function(target_df, FUNCTION){
  #FUNCTION = ar_ts
  j = 12 #n ahead
  ntotal <- length(target_df$STD_Cases)#+1
  trainingSize = round(ntotal*.7)
  #60 #will cause problems with the shorter datasets if left at flat 60
  temp_roll_ase = c() #holder
  temp_ase_matrix = matrix(0, ncol = 12, nrow = length(1:(ntotal-(trainingSize + j) + 1))) #preallocation
  
  for(k in 1:(ntotal-(trainingSize + j) + 1)){
    # print(substitute(FUNCTION)) #use subsitute to return function name as string
    if(substitute(FUNCTION) == 'nnc'){ #use subsitute to return function name as symbol/match
      temp_forecasts <- FUNCTION(target_df[k:(k+(trainingSize-1)),], j, 5, c(10, 10, 10), FALSE)
      for(i in 1:12){
        wstart <- trainingSize + k 
        wend <- trainingSize + k + i -1
        #print(paste(wstart, ':', wend))
        temp_ase_matrix[k, i] <- mean((target_df$STD_Cases[(wstart:wend)]-temp_forecasts$forecast[1:i])^2)
      }}
    else{
      temp_forecasts <- FUNCTION(j, target_df[k:(k+(trainingSize-1)), ])#feed ar_ts dataframe with shifting rows
      for(i in 1:12){
        wstart <- trainingSize + k 
        wend <- trainingSize + k + i -1
        #print(paste(wstart, ':', wend))
        temp_ase_matrix[k, i] <- mean((target_df$STD_Cases[(wstart:wend)]-temp_forecasts[1:i])^2)
      }}
  }
  #print(k)
  
  closeAllConnections()
  for(i in 1:12){
    temp_roll_ase[i] <-mean(temp_ase_matrix[, i])}
  return(temp_roll_ase)
  #return(temp_ase_matrix)
}
#have to sink/closeallconnections the function to hide tswge table output
```
##########################
###END FUNCTION STORAGE###
##########################
```{r}
#PRODUCT CUSTOMER COMBO SELECTOR
product_name <- 'CARSTAIRS BLEND 80  1L' #put lever here
#combolist <- combinations0[which(combinations0$Product == product_name), ]
combolist <- combinations[which(combinations$Product == product_name), ]
#get list of df from combolist
z <- df[which(df$Product == product_name), ]
z$date <- as.Date(z$date, '%m/%d/%Y')
proto_df_list = list()
for(i in seq(1, length(combolist$Customer_ID), 1)){
  #print(combolist$Customer_ID[i])
  y = z[which(z$Customer_ID == combolist$Customer_ID[i]), ]
  proto_df_list[[i]] <- y
  #use df_list[[n]] to access each dataframe in format
  #min(as.Date(df$date, '%m/%d/%Y'))
}

#date to line up each prod/cust combo
full_date_range = seq(from = min(as.Date(df$date, '%m/%d/%Y')), to = max(as.Date(df$date, '%m/%d/%Y')), by = 'month')
#get full range of dates to 'expand' and reveal missing data
df_template <- data.frame(date = full_date_range)

df_list = list()#store fixed df here

for(f in 1:length(proto_df_list)){
  mtest <- data.frame(left_join(df_template, proto_df_list[[f]], by = 'date'))
  mtest[is.na(mtest)] <- 0
  df_list[[f]] <- mtest
}#This makes df's date-contigous

#gen ase holders and forecast holders
modelnames = c('EqualMeans', 'AR', 'ARMA', 'ARI', 'ARIMA', 'ARI_S12', 'ARIMA_S12', 'RF', 'MLP')
modelnames2 <- c('Actual', paste(modelnames, '_ASE'), paste(modelnames, '_F'))
#two tables/dataframes, for ase and f, though shouldn't need f for the final output 
# for(s in modelnames){
#   for(i in 1:12){
#     assign(paste(s, i, 'ASE', sep = '_'), double())
#     assign(paste(s, i, 'F', sep = '_'), double())
#     assign(paste('actual', i), double())
#   }} #changed formatting of ase and forecast holders to make result indexing easier

#store results/forecasts in easily indexible dataframe
r_fcast <- matrix(data = 0, nrow = 12, ncol = (length(modelnames) + 1)) %>% as.data.frame()
names(r_fcast) <- c('actual', modelnames) 
#store ase in easily indexible dataframe
r_ase <- matrix(data = 0, nrow = 12, ncol = length(modelnames)) %>% as.data.frame()
names(r_ase) <- modelnames

#store misc stuff here
misc_holder <- c()
#store future predictions and winning model its based on per cust ID
iter_holder <- data.frame(matrix(data = 0, ncol = length(df_list), nrow = 12+2)) #12 preds + 2 ids
#transpose after for left to right time progression
```

```{r, include=FALSE}
start_time <- Sys.time()

for(s in 1:length(df_list)){ #target assignment, cycle through df_list per custID 
  target_df = df_list[[s]]
  target_df$date <- as.Date(target_df$date, '%m/%d/%Y') #Date fix, char form messes with ordering
  target_df <- target_df[order(target_df$date), ]
  trainingSize = round(length(target_df$Customer_ID)*.7)
  #trainingSize = 60
  j = 12
  r_fcast['actual'] <- target_df$STD_Cases[trainingSize:(trainingSize+j-1)]
  
  #take the column name at match it to function, gen ASE, forecasts, and winning model 
  for(i in names(r_ase)){
    sink()
    if(i == 'EqualMeans'){r_ase[i] <- ase_gen(target_df, em_ts)
    r_fcast[i] <- em_ts(12, target_df)}
    #else if(i == 'AR'){r_ase[i] <- ase_gen(target_df, ar_ts_boot)
    else if(i == 'AR'){r_ase[i] <- ase_gen(target_df, ar_ts)
    r_fcast[i] <- ar_ts(12, target_df)}
    #else if(i == 'ARMA'){r_ase[i] <- ase_gen(target_df, arma_ts_boot)
    else if(i == 'ARMA'){r_ase[i] <- ase_gen(target_df, arma_ts)
    r_fcast[i] <- arma_ts(12, target_df)}
    #else if(i == 'ARI'){r_ase[i] <- ase_gen(target_df, ari_ts_boot)
    else if(i == 'ARI'){r_ase[i] <- ase_gen(target_df, ari_ts)
    r_fcast[i] <- ari_ts(12, target_df)}
    #else if(i == 'ARIMA'){r_ase[i] <- ase_gen(target_df, arima_ts_boot)
    else if(i == 'ARIMA'){r_ase[i] <- ase_gen(target_df, arima_ts)
    r_fcast[i] <- arima_ts(12, target_df)}
    #else if(i == 'ARI_S12'){r_ase[i] <- ase_gen(target_df, ari_ts_boot)
    else if(i == 'ARI_S12'){r_ase[i] <- ase_gen(target_df, ari_ts)
    r_fcast[i] <- ari_s12_ts(12, target_df)}
    #else if(i == 'ARIMA_S12'){r_ase[i] <- ase_gen(target_df, arima_s12_ts_boot)
    else if(i == 'ARIMA_S12'){r_ase[i] <- ase_gen(target_df, arima_s12_ts)
    r_fcast[i] <- arima_s12_ts(12, target_df)}
    else if(i == 'RF'){r_ase[i] <- ase_gen(target_df, rf_ts)
    r_fcast[i] <- rf_ts(12, target_df)}
    else if(i == 'MLP'){r_ase[i] <- ase_gen(target_df, nnc)
    r_fcast[i] <- nnc(target_df, 12, 10, c(10, 10, 10), FALSE)}
    else{break()
      print('unrecognized model name')}}
  
  #should update r_ase with the relvant ASE per 'window size' 1:12
  
  #end_time <- Sys.time()
  #print(paste('ellapsed: ', end_time - start_time))
  
  mean_roll_ase_holder = c()
  c = 1
  for(i in names(r_ase)){
    #print( sum((r_fcast['actual']-r_fcast[i])^2)/length(r_fcast[1,]) )
    mean_roll_ase_holder[c] <- sum((r_fcast['actual']-r_fcast[i])^2)/length(r_fcast[1,])
    c = c + 1}
  mean_ase_frame <- data.frame(model_name = names(r_ase), mean_rolling_ase = mean_roll_ase_holder)# %>% t()
  #simple forecast using best ASE for $input n_ahead
  #overall winning model
  gen_winner <- mean_ase_frame$model_name[which.min(mean_ase_frame$mean_rolling_ase)]
  #basic forecast, starting at 12 out from total data
  future_ahead = 12
  if(gen_winner == 'EqualMeans'){temp_cust_forecast = em_ts(future_ahead, target_df)
  }else if(gen_winner == 'AR'){temp_cust_forecast = ar_ts(future_ahead, target_df)
  }else if(gen_winner == 'ARMA'){temp_cust_forecast = arma_ts(future_ahead, target_df)
  }else if(gen_winner == 'ARI'){temp_cust_forecast = ari_ts(future_ahead, target_df)
  }else if(gen_winner == 'ARIMA'){temp_cust_forecast = arima_ts(future_ahead, target_df)
  }else if(gen_winner == 'ARI_S12'){temp_cust_forecast = ari_s12_ts(future_ahead, target_df)
  }else if(gen_winner == 'ARIMA_S12'){temp_cust_forecast = arima_s12_ts(future_ahead, target_df)
  }else if(gen_winner == 'RF'){temp_cust_forecast = rf_ts(future_ahead, target_df)
  }else if(gen_winner == 'MLP'){temp_cust_forecast = nnc(target_df, future_ahead, 10, c(10, 10, 10), FALSE)$forecast
  }else{break()
    print('unknown model type')
  }
  #generates forecasts with the selected model for this particular customerID, loop this for however many customerIDs
  iter_loop <- c(target_df$Customer_ID[1], gen_winner, temp_cust_forecast)
  iter_holder[, s] <- iter_loop
  pred_dates <- seq(tail(target_df$date, 1), by = 'month', length.out = 12 + 1)[2:13]
  #sequence of dates n spaces out from the last predictions of the target df
  #includes starting date, but cut off for storage
}
closeAllConnections()
end_time <- Sys.time()
print(paste('ellapsed: ', end_time - start_time))
#about 10-12min
```

```{r}
#store iter loop rows in array/dataframe of final results
cust_results <- iter_holder %>% t() %>% as.data.frame() #where columns are n_ahead window predictions
#and rows are the customer ID and winning model used to generate predictions
final_results <- c()
for(r in 1:(length(cust_results$V1)-1)){
  #final_results[r] <- sum(as.integer(cust_results[ ,r+2])) #rounding
  final_results[r] <- sum(as.numeric(cust_results[ ,r+2])) #no rounding
}
#TROUBLESHOOT THIS

#aggregate all actual cases by date
#z$date <- as.Date(z$date, '%m/%d/%Y') #moved further up the lien
#dlist <- sort(as.Date(unique(z$date), '%m/%d/%Y'))
dlist <- sort(unique(z$date))
clist = c()
i = 1
for(d in dlist){
  clist[i] <- sum(z[z$date == d, ]$STD_Cases)
  i = i + 1}
actuals = data.frame(date = dlist, cases = clist)
actuals$id = rep('actual', length(actuals$date))
#add prediction/date frame to end and add category for plotting
predictions = data.frame(date = pred_dates, cases = final_results)
predictions$id = rep('prediction', length(predictions$date))

#final viz output - actual data + simple prediction line
final_data <- rbind(actuals, predictions)
v1 <- ggplot(data = final_data) +
  geom_line(aes(x = date, y = cases, color = id)) +
  ggtitle(paste('12 Month Forecast:', product_name)) + xlab('Date') + ylab('Cases') +
  labs(color = '')
show(v1)
```


structure - 
- read data
- choose product
- get all cust_ID associated with that product from combinations (or combinations0??)
- training section
- run model testing for n_ahead 1:12 for each customer
- aggregate lowest ASE forecasts from each model for the n_ahead 1:12 [BUT THIS IS PAST DATA??? ]
- determine which type of model has the lowest ASE for each n interval

- Prediction section
- taking the best performing model from each n interval, predict out to that interval and THEN get the 12 possible future values
- will likely need to write a function for prediction with the rest of the models 
- aggregation
- then for each model aggregate those 12 real forecasts into 12 total values for n+1:12 for that product

- results
- grab aggregate values of total cases for selected product and store in univariate ts object
- plot this on graph next to +12 forecasted values
- reach goal - confidence intervals ??? 

reach goals 
- date input slider/range input for data to feed models on, at the very beginning of the workflow 





```{r}
# #gen ase holders and forecast holders
# modelnames = c('EqualMeans', 'AR', 'ARMA', 'ARI', 'ARIMA', 'ARI_S12', 'ARIMA_S12', 'RF', 'MLP')
# modelnames2 <- c('Actual', paste(modelnames, '_ASE'), paste(modelnames, '_F'))
# #create empty matrix to hold training results (training results matrix) 
# trm <- matrix(0, ncol = length(modelnames2), nrow = 12)
# trdf <- data.frame(trm)
# names(trdf) <- sort(modelnames2)
# 
# # for(s in modelnames){
# #   for(i in 1:12){
# #   assign(paste(s, i, 'ASE', sep = '_'), double())
# #   assign(paste(s, i, 'F', sep = '_'), double())
# #   assign(paste('actual', i), double())
# #     }
# # } #changed formatting of ase and forecast holders to make result indexing easier
# #would require structural changes to most of the current codeeeeee
```

doesn't really correct for different intervals in dates, ex ,sometimes the sales go from january to august with nothing in between? nvm, sorting by date fixes most of that 

